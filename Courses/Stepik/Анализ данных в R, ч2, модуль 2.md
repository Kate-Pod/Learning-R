## Анализ данных в R. Часть 2
###  Подробнее о визуализации
#### Грамматика ggplot2, функция qplot
**Задачи:**  
**1:** Используя функцию qplot, постройте гистограмму переменной depth из данных diamonds. Сохраните график в переменную depth_hist.
```{r}
depth_hist <- qplot(diamonds$depth)
```
**2:** Теперь давайте отобразим сразу три переменные на одном графике!
Постройте диаграмму рассеивания (scatter plot) как в указанном ниже примере, результат сохраните в переменную price_carat_clarity_points.
данные - diamonds
ось x - carat
ось y - price
цвет точек - clarity
```{r}
price_carat_clarity_points <- qplot(x=carat,y=price,color=clarity,data=diamonds)
```
**3:** Используя функцию qplot, постройте график плотности переменной x из данных diamonds. Сохраните график в переменную x_density.
```{r}
x_density <- qplot(x = x, data = diamonds, geom = "density")
```
**4:** Усложним задачу, постройте график плотности переменной x для каждой группы наблюдений по переменной cut из данных diamonds. Таким образом за цвет графика теперь отвечает переменная cut. Сохраните результат в переменную x_cut_density.
```{r}
x_cut_density <-qplot(x=x, geom='density',color=cut, data=diamonds)
```
**5:** Давайте знакомиться с различными geoms. Документация пакета и весь список с примерами использования доступен здесь. Вообще обратите внимание на документацию ggplot2, очень подробное описание основных возможностей пакета!
Давайте построим график violin plot для переменной price в каждой группе наблюдений по переменной color. Сохраните результа в переменную price_violin.
```{r}
price_violin <- qplot(x = color,
      y = price,
      data = diamonds,
      geom = "violin")
```
#### Функция ggplot и различные geoms
**Задачи:**  
**1:** Давайте потренируемся комбинировать различные geoms на одном графике. Используя данные mtcars скомбинируем два варианта отображения количественных данных boxplot и violin plot.
ось x - am (нужен фактор)
ось y - mpg
Сохраните график в переменную my_plot.
```{r}
my_plot <- ggplot(mtcars,aes(factor(am),mpg))+geom_violin()+geom_boxplot(width = 0.2)
```
**2:** Отобразите взаимосвязь между доходом (income) и числом продаж (sale), цветом точек указав номер магазина (shop):
Сохраните график в переменную my_plot. Обратите внимание, что линия тренда одна для всех наблюдений. Данные хранятся в переменной sales.
```{r}
my_plot <- ggplot(mtcars,aes(factor(am),mpg))+geom_violin()+geom_boxplot(width = 0.2)
```
**3:** При помощи функции stat_summary постройте график с доверительными интервалами для демонстрации различий в доходах двух магазинов с учетом времени года:
переменная shop - ось x;
переменная income - ось y;
переменная season - цвет;
geom pointrange.
Сохраните график в переменную my_plot, дополнив предложенный код. Обратите внимание, что доверительные интервалы не накладываются друг на друга! 
```{r}
my_plot <- ggplot(sales, aes(shop, income, col = season)) +
  stat_summary(fun.data = mean_cl_boot,
               position = position_dodge(0.2),
               size = 1)
```
**4:** Теперь давайте отобразим на графике различия в продажах (переменная sale), в зависимости от:
года (date) - ось x;
и номера магазина (shop) - цвет.
Используйте функцию mean_cl_boot для построения доверительных интервалов.Вам также понадобится использовать три geoms: errorbar, point, line. Используйте их прямо внутри функции stat_summary().
```{r}
my_plot <- ggplot(sales, aes(date,sale,col=shop))+
  stat_summary(fun.data = mean_cl_boot,geom='errorbar', position = position_dodge(0.2)) + # добавим стандартную ошибку
  stat_summary(fun.data = mean_cl_boot,geom='point',position = position_dodge(0.2)) + # добавим точки
  stat_summary(fun.data = mean_cl_boot,geom='line',position = position_dodge(0.2))
```
#### Facet - способы группировки данных на графике
**Задачи:**  
**1:** Потренируемся с разбиением графика на подгруппы! Используя facet_grid постройте следующий график и сохраните его в переменную mpg_facet.
ось x - переменная mpg
facet - переменная am по строчкам и vs по столбцам
```{r}
mpg_facet <- ggplot(mtcars,aes(mpg))+geom_dotplot()+facet_grid(am~vs)
```
**2:** Используя данные iris, постройте график плотности для переменной Sepal.Length. Разбейте график на части по переменной Species при помощи facet_wrap. Результат сохраните в переменную sl_wrap.
```{r}
sl_wrap <- ggplot(iris,aes(Sepal.Length))+geom_density()+facet_wrap(~Species)
```
**3:** Используя данные Iris, постройте график, иллюстрирующий взаимосвязь переменных Sepal.Length и Sepal.Width внутри каждого вида (переменной Species), при помощи facet_wrap().
В этом задании вам потребуется использовать два geom:
geom_point - для отображения отдельных наблюдений,
geom_smooth - для добавления сглаживания.
Сохраните график в переменную my_plot.
```{r}
my_plot <- ggplot(iris,aes(Sepal.Length, Sepal.Width))+geom_point()+
  facet_wrap(~Species)+geom_smooth()
```
**4:** Давайте построим следующий график, чтобы выяснить есть ли различия в бюджетах фильмов разного жанра из года в год. Cохраните результат в переменную my_plot.
ось x - переменная Type
ocь y - переменная Budget
facet - переменная Year (используйте facet_grid)
```{r}
my_plot <- ggplot(myMovieData, aes(Type, Budget)) + 
  geom_boxplot() + 
  facet_grid(. ~ Year) +
  theme(axis.text.x = element_text(angle = 90, hjust = 1))
```

#### Scale и Theme: оси, легенда, внешний вид графика

**Задача:**  
**1:** В этом задании мы построим график используя данные Iris. Наша цель отобразить взаимосвязь переменных Sepal.Length (ось X) и Petal.Length (ось Y) внутри трех групп по переменной Species. Для этого постройте scaterplot, отобразите цветом значения переменной Species и добавьте линейное сглаживание в каждой группе.

Далее от вас потребуется привести график к более завершенному виду. Мы переведем на русский название осей, название легенды и ее расшифровку:

Ось X - "Длина чашелистика".
Ось Y - "Длина лепестка".
Название легенды - "Вид цветка".
Расшифровка легенды: "Ирис щетинистый", "Ирис разноцветный", "Ирис виргинский".
Также мы чуть измени отображение значений по осям.

Значения по оси X должны начинаться с 4 и заканчиваться на 8 с шагом в единицу.
Значения по оси Y должны начинаться с 1 и заканчиваться на 7 с шагом в единицу.

```{r}
iris_plot <- ggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +
  geom_point() +
  geom_smooth(method = "lm") + # линенйное сглаживание
  scale_x_continuous(name = "Длина чашелистика",
                     breaks = seq(4, 8 , 1),
                     limits = c(4,8)) + 
  scale_y_continuous(name = "Длина лепестка",
                     breaks = seq(1, 7, 1),
                     limits = c(1, 7)) + 
  scale_color_discrete(name = "Вид цветка",
                       labels = c("Ирис щетинистый",
                                  "Ирис разноцветный",
                                  "Ирис виргинский"))
```
#### Динамическая визуализация с plotly

**Задача:**  
**1:** Любый уважающий себя исследователь должен уметь нарисовать трехмерный чайник в R! Датасет (ссылка) содержит информацию о полигонах трехмерной модели чайника. Три столбца таблицы задают координаты (x,y,z), а тройки строк задают треугольники (т.е. строки 1,2,3 - первый треугольник, 4,5,6 - второй, и так далее).
Напишите функцию, которая будет принимать data.table с этими данными, и возвращать объект plotly с трехмерной моделью. Следует воспользоваться установкой индексов i,j,k.

`с чайником пришлось повозиться...
```{r}
make.fancy.teapot <- function(teapot.coords){
  i <- seq(0,nrow(teapot.coords)-1,by=3)	
  j <- seq(1,nrow(teapot.coords),by=3)	
  k <- seq(2,nrow(teapot.coords),by=3)	
    
    rez <- plot_ly(data.table(teapot.coords),x=x,y=y,z=z,i=i,j=j,k=k
                   ,type='mesh3d'
                   )
  return(rez)
}
```



