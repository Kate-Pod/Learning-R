## Анализ данных в R
### Статистика в R. Часть 1
#### Анализ номинативных данных

`binom.test`(x=5,n=20,p=0.5) # x - кол-во исходов, n - кол-во наблюдений, p - вероятность успешного исхода(по умолчанию 0,05)  
`chisq.test`() # Хи2 тест  
`fisher.test`() #тест Фишера

**Задачи:**  
**1:** Воспользуемся данными diamonds из библиотеки ggplot2. При помощи критерия Хи - квадрат проверьте гипотезу о взаимосвязи качества огранки бриллианта (сut) 
и его цвета (color). В переменную main_stat сохраните значение статистики критерия Хи - квадрат. Обратите внимание, main_stat должен быть вектором из одного элемента, 
а не списком (листом).

```{r}
t1 <- table(diamonds$cut, diamonds$color)
main_stat <- chisq.test(t1)[1]
```
**2:** При помощи критерия Хи - квадрат проверьте гипотезу о взаимосвязи цены (price) и каратов (carat) бриллиантов. Для этого сначала нужно перевести эти количественные переменные в формат пригодный для Хи - квадрат. Создайте две новые переменные в данных diamonds:
factor_price - где будет 1, если значение цены больше либо равно чем среднее, и 0, если значение цены ниже среднего цены по выборке.
factor_carat - где будет 1, если число карат больше либо равно чем среднее,  и 0, если ниже среднего числа карат по выборке.

```{r}
dia <- data.frame(diamonds)
dia$factor_price <- ifelse(dia$price>=mean(dia$price),1,0)
dia$factor_carat <- ifelse(dia$carat>=mean(dia$carat),1,0)
main_stat <- chisq.test(dia$factor_price,dia$factor_carat)[1]]
```

**3:** При помощи точного критерия Фишера проверьте гипотезу о взаимосвязи типа коробки передач (am) и типа двигателя (vs) в данных mtcars. Результат выполнения критерия сохраните в переменную.Получившийся p - уровень значимости сохраните в переменную fisher_test.
```{r}
fisher_result <- fisher.test(mtcars$am,mtcars$vs)
fisher_test <- fisher_result$p.value
```

#### Сравнение двух групп
`shapiro.test`(df$Sepal) # тест на нормальное распределение (Shapiro-Wilko test)
`bartlett.test`(Sepal~Species,df) # проверка на гомогенность дисперсий, критерий Бартлетта
`t.test`() # t-критерий
`wilcox.test`(Length~Species,df) # Манн-Уитни тест

**Задачи:**  
**1:** Воспользуемся еще одним встроенным набором данных в R  - ToothGrowth. Данные позволяют исследовать рост зубов у морских свинок в зависимости от дозировки витамина C и типа потребляемых продуктов.
Сравните среднее значение длины зубов свинок, которые потребляли апельсиновый сок (OJ) с дозировкой 0.5 миллиграмм, со средним значением длины зубов свинок, которые потребляли аскорбиновую кислоту (VC) с дозировкой 2 миллиграмма. 
Значение t - критерия сохраните в переменную t_stat.
```{r}
df <- ToothGrowth
test <-  t.test(df$len[df$supp=="OJ"&df$dose==0.5],df$len[df$supp=="VC"&df$dose==2])
t_stat <- test$statistic
```
#### Дисперсионный анализ
fit<-`aov`(price~origin,data=mydata) # дисперсионный анализ: насколько происхождение товара влияет на его цену
summary(fit)

#### Создание собственных функций

**Задачи:**  
**1:** Напишите функцию, которая выводит номера позиций пропущенных наблюдений в векторе.
На вход функция получает числовой вектор с пропущенными значениями. Функция возвращает новый вектор с номерами позиций пропущенных значений.

```{r}
NA.position <- function(x){
       return(c(which(T == is.na(x))))
}
```
**2:** Напишите функцию NA.counter для подсчета пропущенных значений в векторе.
На вход функция  NA.counter должна принимать один аргумент - числовой вектор. Функция должна возвращать количество пропущенных значений.


```{r}
NA.counter <- function(x){
res <- which(is.na(x))
length(res)
}
```
**3:** Напишите функцию filtered.sum, которая на вход получает вектор с пропущенными, положительными и отрицательными значениями и возвращает сумму положительных элементов вектора.
```{r}
filtered.sum <- function(x){
 return(sum(x[x>0],na.rm=T))
  }
```
**4:** Напишите функцию outliers.rm, которая находит и удаляет выбросы. Для обнаружения выбросов воспользуемся самым простым способом, с которым вы не раз встречались, используя график Box plot. 
Выбросами будем считать те наблюдения, которые отклоняются от 1 или 3 квартиля больше чем на 1,5 *  IQR, где  IQR  - межквартильный размах.
На вход функция получает числовой вектор x. Функция должна возвращать модифицированный вектор x с удаленными выбросами. 

```{r}
outliers.rm <- function(x, na.rm = TRUE) {
  qnt <- quantile(x, probs=c(0.25, 0.75), na.rm = na.rm)
  H <- 1.5 * IQR(x, na.rm = na.rm)
  y <- x
  y[x < (qnt[1] - H)] <- NA
  y[x > (qnt[2] + H)] <- NA
  y
}

```


