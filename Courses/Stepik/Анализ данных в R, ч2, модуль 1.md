## Анализ данных в R. Часть 2
###  Продвинутая предобработка данных
#### Функции семейства apply
**Задачи:**  
**1:** В переменной my_df сохранен dataframe с произвольным числом количественных переменных. При помощи функции apply найдите максимальное значение в каждой строке. Сохраните результат (вектор максимальных значений) в переменную row_max.
```{r}
row_max <- apply(my_df, MARGIN = 1, FUN = max)
```
**2:** В переменной my_df сохранен dataframe с произвольным числом количественных переменных. Рассчитайте медиану для всех столбцов с количественными переменными. В переменную col_median сохраните вектор полученных значений. 
```{r}
z <- my_df[sapply(my_df,is.numeric)]
col_median<- sapply(z,median)
```
**3:** Давайте завершим и слегка модифицируем задачу из предыдущей лекции. Напишите функцию get_negative_values, которая получает на вход dataframe произвольного размера. Функция должна для каждой переменной в данных проверять, есть ли в ней отрицательные значения. Если в переменной отрицательных значений нет, то эта переменная нас не интересует, для всех переменных, в которых есть отрицательные значения мы сохраним их в виде списка или матрицы, если число элементов будет одинаковым в каждой переменной (смотри пример работы функции).
```{r}
get_negative_values <- function(test_data) {
  cols <- apply(test_data, 2 ,function(x) any(x < 0, na.rm = TRUE))
  apply(test_data[cols], 2, function(x) x[!is.na(x) & x < 0])
}
```
**4:** Напишите функцию na_rm которая заменяет все пропущенные значения в столбцах dataframe на соответствующее среднее значение. То есть все NA в первом столбце заменяются на среднее значение первого столбца (рассчитанного без учета NA). Все NA второго столбца заменяются на среднее значение второго столбца и т.д.  
Функция na_rm на вход получает dataframe произвольной размерности, состоящий из количественных переменных. Функция должна возвращать  dataframe с замененными NA. Ни порядок столбцов, ни порядок строк в dataframe изменять не нужно.
```{r}
na_rm <- function(x) {
  as.data.frame(apply(test_data, 2, 
                      function(x) ifelse(is.na(x), mean(x, na.rm = T), x)))
}
```
**5:** Напишите функцию positive_sum, которая получает на вход dataframe с произвольным количеством числовых переменных. Основная задача функции - найти сумму положительных значений в каждой переменной и сохранить их в список.
```{r}
positive_sum <- function(test_data) {
  lapply(test_data , function(x) sum(x[x>0], na.rm = T))
}
```
**6:** Предположим у нас есть dataframe с двумя переменными name - название гена, expression - уровень экспрессии. Например:

> my_data
    name expression
1 p1@HPS1       120
2 p2@HPS2       89
3 p@GOT1        45


Обратите внимание, что само название гена спрятано внутри строки и указано после символа @. Напишите функцию my_names, которая получает на вход  датафрейм и вектор с именами тех генов, для которых мы хотим отобрать наблюдения уровня экспрессии. Допустим, мы хотим отобрать наблюдения только для генов 'HPS1' и 'GOT1', тогда результат работы функции будет следующий:

> names =c('HPS1', 'GOT1')
> my_names(my_data, names)
     name expression
1 p1@HPS1        120
3  p@GOT1         45
 
Таким образом в процессе проверки на вход вашей функции будет подаваться два аргумента:

1. Датафрейм, c произвольным количеством строк, где имена генов сохранены в переменной names (фактор)  в формате ****@name , а уровень экспрессии в переменной expression.

2. Вектор с именами генов, для которых мы хотим отобрать наблюдения. Гарантируется, что имена указанные в векторе есть в данных.

Функция возвращает датафрейм с наблюдениями только для указанных генов.
```{r}
my_names <- function (dataset, names){
  one <- sapply(names, function(x) grepl(x, dataset[,1]))
     two <- as.logical(rowSums(one))
   z <-  dataset
  z[1] <- two
  name <-  dataset$name[z$name==TRUE]
  expression <- z$expression[z$name==TRUE]
 return (data.frame(name,expression))
}
```
**7:** Напишите функцию find_outliers, которая получает на вход dataframe с одной количественной переменной и произвольным числом факторных переменных. Факторные переменные разбивают все наши наблюдения на определенное число групп. 
```{r}
library(dplyr)
library(lazyeval)
ToothGrowth$dose <- factor(ToothGrowth$dose)
str(ToothGrowth)

find_outliers <- function(t){
  num_var <- names(which(sapply(t, is.numeric)))
  group_var <- names(which(!sapply(t, is.numeric)))    
  t %>% 
    group_by_(.dots = group_var) %>%
    mutate_(is_outlier = interp(~ifelse(abs(x - mean(x)) > 2 * sd(x), 1, 0), x = as.name(num_var)))
  
}
}
```
**8:** Напишите функцию smart_lm, которая получает на вход data.frame с произвольным числом количественных переменных. Первая колонка в данных - это зависимая переменная, все остальные - предикторы. На первом этапе вы должны отобрать предикторы для модели.
Функция возвращает в виде вектора коэффициенты линейной регрессии построенной только для отобранных предикторов (условие нормальности распределения). Если таких предикторов в данных не оказалось, то функция возвращает предупреждение "There are no normal variables in the data".
```{r}
smart_lm <- function(x){
  library(dplyr)
  a <- x[2:ncol(x)] %>% 
    sapply(function(var) shapiro.test(var)$p.value)
  
  if (length(names(a[a > 0.05])) < 1) {
    print("There are no normal variables in the data")
  } else {
    measurevar <- names(x[1])
    groupvars <- names(a[a > 0.05])
    for_lm <- as.formula(paste(measurevar, paste(groupvars, 
                                                 collapse=" + "), 
                               sep=" ~ "))
   return( lm(for_lm, x)$coefficients)
  }
}
```
**9:** Напишите функцию one_sample_t, которая получает на вход два аргумента:
1. Dataframe произвольного размера с произвольным числом переменных различного типа.
2. Числовое значение среднего в генеральной совокупности.
Ваша функция должна применять одновыборочный t - test к каждой числовой переменной в данных, и сравнивать среднее значение этой переменной с указанным значением среднего в генеральной совокупности (второй аргумент функции).
Функция должна возвращать список, где каждый элемент это вектор, состоящий из t - значения, числа степеней свобод (df) и значения p - value.
```{r}
one_sample_t <- function(test_data, general_mean){
  b <- names(which(sapply(test_data, is.numeric)))
  a <- lapply(test_data[b], function(x) c(t.test(x,mu=general_mean)$statistic,t.test(x,mu=general_mean)$parameter,t.test(x,mu=general_mean)$p.value))
  a
}
```
**10:** Итак, ваша задача, написать функцию get_p_value, которая получает на вход список (назовем его главным списком), каждый элемент этого списка тоже список - результат выполнения функции shapiro.test (смотри пример normality_tests). Ваша задача из каждого элемента главного списка вытащить только p - value. В итоге функция возвращает список где каждый элемент - одно значение - p - value (как в примере normality_tests_p).
```{r}
get_p_value <- function(test_list){
  s2 <- sapply(test_list, '[')
  s2[2,]
  }
```


