## Анализ данных в R
### Статистика в R. Часть 1
#### Корреляция и простая линейная регрессия (МНК)

**Задачи:**  
**1:** Напишите функцию corr.calc, которая на вход получает data.frame с двумя количественными переменными, рассчитывает коэффициент корреляции Пирсона и возвращает вектор из двух значений: коэффициент корреляции и p - уровень значимости.

```{r}
corr.calc <- function(x){
  coef <- cor.test(~ x[[1]] + x[[2]])
  return(c(coef$estimate,coef$p.value))
}
```

**2:** Напишите функцию filtered.cor которая на вход получает data.frame с  произвольным количеством переменных (как количественными, так и любых других типов), рассчитывает коэффициенты корреляции Пирсона между всеми парами количественных переменных и возвращает наибольшее по модулю значение коэффициента корреляции. (То есть функция может вернуть -0.9, если это наибольшая по модулю  корреляция).
Гарантируется наличие в data.frame хотя бы двух количественных переменных.
Обратите внимание: при проверке вашей функции на вход будут подаваться данные с различными именами колонок. Ваша функция должна корректно работать независимо от имен переменных. 

```{r}
filtered.cor <- function(x){
  df_num <- x[,sapply(x, is.numeric)]   # отбор количественных переменных
  df <- cor(df_num)
  diag(df)<-0 # в матрице по диагонали убираем единицы
   return(df[which.max(abs(df))]) # возвращает максимальное по модулю значение
}
```

**3:** Напишите функцию smart_cor, которая получает на вход dataframe с двумя количественными переменными. Проверьте с помощью теста Шапиро-Уилка, что данные в обеих переменных принадлежат нормальному распределению.
Если хотя бы в одном векторе распределение переменной отличается от нормального (p - value меньше 0.05), то функция должна возвращать коэффициент корреляции Спирмена. (Числовой вектор из одного элемента).
Если в обоих векторах распределение переменных от нормального значимо не отличается, то функция должна возвращать коэффициент корреляции Пирсона.

```{r}
smart_cor <- function(x){
 p1 <- shapiro.test(x[[1]])
 p2 <- shapiro.test(x[[2]])
  if (p1$p.value < 0.05 | p2$p.value<0.05)  {
  return(cor.test(x[[1]], x[[2]], method = 'spearman')$estimate)
  }else{
    return(cor.test(x[[1]], x[[2]])$estimate)
   } 
  }
```

**4:** Воспользуемся уже знакомыми данными diamonds из библиотеки ggplot2. Только для бриллиантов класса Ideal (переменная cut) c числом карат равным 0.46 (переменная carat) постройте линейную регрессию, где в качестве зависимой переменной выступает price, в качестве предиктора - переменная  depth. Сохраните коэффициенты регрессии в переменную fit_coef.

```{r}
datax <- diamonds
p1 <- subset(datax,cut=="Ideal"&carat=='0.46')
lmj  <- lm(price ~ depth, p1)
fit_coef<-lmj$coefficients
```
**5:** Напишите функцию regr.calc, которая на вход получает dataframe c двумя переменными.
Если две переменные значимо коррелируют (p - уровень значимости для коэффициента корреляции Пирсона меньше 0.05), то функция строит регрессионную модель, где первая переменная - зависимая, вторая - независимая. Затем создает в dataframe новую переменную с назанием fit, где сохраняет предсказанные моделью значения зависимой переменной. В результате функция должна возвращать исходный dataframe с добавленной новой переменной fit.
Если две переменные значимо не коррелируют, то функция возвращает строчку "There is no sense in prediction"

```{r}
regr.calc <- function(x){
  correl <- cor.test(x[[1]],x[[2]])
  if(correl$p.value<0.05){
    lmj <- lm(x[[1]]~x[[2]],x)
    x$fit <- predict(lmj,x)
    return(x)
  }else{
   return("There is no sense in prediction")
  }
```
**6:** Постройте scatterplot по данным iris, сохранив его в переменную my_plot : 
Ось X - переменная Sepal.Width
Ось Y -  переменная Petal.Width
Цвет точек - переменная Species
Также добавьте линейное сглаживание для каждой группы наблюдений по переменной Species.

```{r}
library(ggplot2)
my_plot <-ggplot(iris, aes(Sepal.Width, Petal.Width,col=factor(Species)))+
  geom_point()+
    geom_smooth(method = "lm")
```

#### Множественная линейная регрессия

`lm`(Fertility~Examination+Catholic,data=swiss)

**Задачи:**  
**1:** Напишите функцию fill_na, которая принимает на вход данные с тремя переменными:
x_1  -  числовой вектор
x_2 - числовой вектор
y - числовой вектор с пропущенными значениями.
На первом этапе, используя только наблюдения, в которых нет пропущенных значений, мы построим регрессионную модель (без взаимодействий), где  y — зависимая переменная, x_1 и x_2 — независимые переменные. Затем, используя построенную модель, мы заполним пропущенные значения предсказаниями модели.
Функция должна возвращать dataframe c новой переменной  y_full. Сохраните в нее переменную y, в которой пропущенные значения заполнены предсказанными значениями построенной модели.

```{r}
fill_na <- function(x){
  lmj <- lm(y~x_1+x_2,data=x, na.action = "na.exclude")
   x$y_full <- predict(lmj ,x)
  x$y_full <- ifelse(is.na(x$y), x$y_full, x$y)
   return(x)
}
```
**2:** В переменной df сохранен subset данных mtcars только с переменными "wt", "mpg", "disp", "drat", "hp". Воспользуйтесь множественным регрессионным анализом, чтобы предсказать вес машины (переменная "wt"). Выберите такую комбинацию независимых переменных (из "mpg", "disp", "drat", "hp"), чтобы значение R^2 adjusted было наибольшим. Взаимодействия факторов учитывать не надо. 
```{r}
model <- lm(wt ~mpg+disp+hp,df)
```
**3:**
Визуализируйте взаимодействие переменных wt и am, дополнив код, приведённый в задании:
Ось x - переменная wt
Ось y - переменная mpg
Цвет регрессионных прямых - переменная am
```{r}
library(ggplot2)
mtcars$am <- factor(mtcars$am) # сначала переведем переменную am в фактор
my_plot <- ggplot(mtcars, aes(x = wt, y = mpg, col = factor(am))) +  # теперь строим график
    geom_smooth(method = 'lm')
```


#### Диагностика модели
`scale`- стандартизация вектора (среднее=0, sd=1)

**Задачи:**  
**1:** Напишите функцию, которая на вход получает dataframe с двумя количественными переменными, а возвращает стандартизованные коэффициенты для регрессионной модели, в которой первая переменная датафрейма выступает в качестве зависимой, а вторая в качестве независимой.
```{r}
beta.coef <- function(x){
 x <-  scale(x,center= TRUE, scale=TRUE)
  x <- as.data.frame(x)
 lmj <- (lm(x[[1]]~x[[2]],x))
  return(lmj$coefficients)
}
```
**2:** Напишите функцию normality.test, которая получает на вход dataframe с количественными переменными, проверяет распределения каждой переменной на нормальность с помощью функции shapiro.test. Функция должна возвращать вектор с значениями p - value, полученного в результате проверки на нормальность каждой переменной. Названия элементов вектора должны совпадать с названиями переменных. 

```{r}
normality.test <- function(x){
res <- vector(length = length(x))
for(i in 1:length(x)){
res[i] <- shapiro.test(x[[i]])$p.value
}
names(res) <- names(x)
res
}
```

**3:** Напишите функцию high.corr, которая принимает на вход датасет с произвольным числом количественных переменных и возвращает вектор с именами двух переменных с максимальным абсолютным значением коэффициента корреляции .

```{r}
high.corr <- function(x){
l <- length(x)
res <- matrix(nrow = l, ncol = l)
for(i in 1:(l-1)){
for(j in (i+1):l){
k <- cor.test(x[[i]], x[[j]])$estimate
res[i, j] = k[["cor"]]
}
}
res[is.na(res)] <- 0
res <- abs(res)
res_row <- which.max(res) %% l
res_col <- which.max(res[res_row,])
return(c(names(x[res_row]), names(x[res_col])))
}
```

