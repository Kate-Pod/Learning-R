## Основы программирования в R
### Модуль 1: базовые структуры и понятия
#### Векторы
x <- 2 # сохраняем объект  
z<-c(1,2,-3) - #вектор чисел  
z[3] = -3  
v1[v1>0] - #значения больше 0  
seq(1,2,by=0.25) - #последовательность от 1 до 2 с шагом 0,25  
rep(1:3,times=3) - #повторение (123 123 123)  
rm() - #удаление переменных  
ls() - # проверка, что осталось    
rm(list()=ls()) - #удаление всех переменных  
sort(c(x,y)) - #упорядочить вектор  
typeof(вектор) - #тип вектора

#### Функции
function(){} - в круглых скобках аргументы функции, в фигурных - тело (код, который будет исполнен)

**Задачи:**  
**1:** *Напишите функцию get_fractions, которая принимает на вход два числа, m и n, и возвращает аналогичный вектор, содержащий все дроби вида {i/m, i = 0, 1, ..., m} и  {j/n, j = 0, 1, ..., n}. Вектор не должен содержать повторов. И должен быть упорядочен в порядке убывания.*
```{r}
get_fractions <- function(m, n) {
sort (  
unique (                               #избегаем повторов с unique
c(seq(0,1,by=1/m),seq(0,1, by=1/n)) ), #задаем вектор с последовательностями от 0 до 1 с шагом 1/m и 1/n
decreasing = TRUE)                     #упорядочиваем по убыванию
}
```
***
#### Условия `if` и `ifelse`

if (condition) {do smth} else {do another thing} 
>-нельзя переносить `else` на другую строку  

ifelse(condition,action,another action) 
>-`print` можно не писать

*Примеры:*
```{r}
if (sqrt(2) > 1.5) {
  print("Greater!") #вывести на печать
} else {
  print("Less!")
}
```
```{r}
if (c(TRUE, FALSE)) print("Hmm...?")
```
```{r}
ifelse(runif(8) > 0.5, "Орёл", "Решка") #runif - генерация чисел
```
```{r}
x <- runif(8)
ifelse(x > 2/3, "Камень", 
       ifelse(x > 1/3, "Ножницы", "Бумага"))
```
**Задачи:**  
**1:** *Функция dice_roll(n) должна выдавать n независимых бросков игрального кубика. Допустимые значения, разумеется, в диапазоне от 1 до 6. Все грани выпадают с равной вероятностью.*
```{r}
dice_roll <- function(n) {
as.integer (                 #целое число
runif(n,min=1,max=7) )       #генерируем последовательность от 1 до 7
}
```
***
#### Циклы: 
`repeat`

```{r}
i <- 0
repeat {
  i <- i + runif(1)
  print(i)
  if (i > 5) break
}
```
`while`

```{r}
i <- 2^14
while (i > 1000) {
  i <- i/2
  print(i)
}
```
`for`

```{r}
for (i in 1:8) {
  if (i %% 2 == 0) print(i)
}
```
>-Внутри цикла необходимо вызывать функцию print

```{r}
for (i in letters) {
  if (i == "b") next
  if (i == "d") break
  print(i)
}
```

```{r}
for (i in 1:5) i
```
**Задачи:**  
**1:** *Пусть вектор называется нестрого возрастающим, если каждый следующий элемент в нём не меньше, чем предыдущий. Точно так же, вектор назовём нестрого убывающим, если каждый следующий элемент в нём не больше, чем предыдущий. Напишите функцию, которая принимает один аргумент (числовой вектор) и возвращает TRUE, если вектор обладает свойством нестрогой монотонности, то есть является либо несторого возрастающим, либо нестрого убывающим. В противном случае функция возвращает FALSE.  
Пример. x=c(0, 0, 3, 4, 4, 8) нестрого возрастает, возвращаем TRUE. y=c(3:0, 1) был бы нестрого убывающим, если бы не последняя единица, поэтому возвращаем FALSE.*
```{r}
is_monotone <- function(x) {        # '|' обозначается как 'или' (можно использовать 'any')  
return (                            # 'all' - все ли значения логического вектора TRUE?
all( x[-length(x)]<=x[-1] ) |       #конструкцией 'x[-length(x)]' исключаем из x последний его элемент
all( x[-length(x)]>=x[-1] ) )       #конструкцией 'x[-1]' исключаем из x первый его элемент
}

```
